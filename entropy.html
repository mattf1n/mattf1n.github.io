<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Matthew Finlayson" />
  <title>Decoding strategies and entropy</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="mattf1n.github.io/style/main.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Decoding strategies and entropy</h1>
<p class="author">Matthew Finlayson</p>
</header>
<p>My hypothesis is that we can characterize the relationships between
different decoding methods and hyperparameters by looking at their
entropy. We can use these relationships to predict which decoding method
is most appropriate for a task (a task is a metric plus a set of
instances over which to measure) without doing an expensive exhaustive
hyperparameter sweep.</p>
<p>The entropy of a decoding strategy with parameter <span
class="math inline">\(p\)</span> is the expected entropy of the
next-token distributions for all contexts sampled from a language. This
can be estimated by finding the average next-token entropy over a
corpus.</p>
<aside>
Of course, this is not the only way to define the entropy of a decoding
strategy, and only makes sense for token-level decoding strategies like
top-p or temperature. MBR decoding is not token-level. One might define
a measure of decoding method entropy as the entropy over
<em>generations</em>, e.g., the expected log-probability of the
<em>sequence</em> generated by the model. See <a
href="https://en.wikipedia.org/wiki/Entropy_estimation">this article</a>
for an overview of some of the approaches and challenges associated with
estimating entropy.
</aside>
<p>We are focused on entropy because this is measurable across decoding
strategies. Entropy captures how diverse a decoding methodâ€™s generations
are. High entropy means diverse, low entropy means deterministic, or
close to greedy.</p>
<p>What we want is a function that takes <span
class="math display">\[\arg\max_\texttt{param}\texttt{metric}(\texttt{param}\mid\texttt{strat},\texttt{task})\]</span>
and gives a latent variable <span
class="math inline">\(\texttt{entropy}\)</span> and a function that
takes <span class="math inline">\(\texttt{entropy}\)</span> and gives
<span
class="math display">\[\arg\max_\texttt{param}\texttt{metric}(\texttt{param}\mid\texttt{strat},\texttt{task})\]</span>
for each <span class="math inline">\(\texttt{task},
\texttt{metric}\)</span>. In other words, we want an invertible function
for each strategy that translates optimal parameters into a latent
variable which fully describes the entropy level of the task, agnostic
of which decoding method is being used.</p>
<p>The first step of our experiments should be to try to see if such a
function exists. To do this we might plot optimal parameters for two
different decoding methods against each other. The x-axis should be
hyperparams from method <span class="math inline">\(a\)</span>, y-axis
hyperparams from method <span class="math inline">\(b\)</span>. Data
points should represent different tasks. To find a data point, do a
hyperparam sweep for both methods on a task, identify the best
hyperparam for both methods, enter the data point on the plot. We can
then see if there is a pattern.</p>
<p>After we have done this, we can turn our attention to predicting the
peformance of the methods.</p>
</body>
</html>
